/**
 * html5网页3D雪花特效插件
 * @author chendaiming
 * @params {
 * 		  images : 雪花颗粒图片
 * 		   fuzzy : 雪花颗粒模糊度 默认70
 * 	 maxParticle : 雪花颗粒最大数量 默认10000
 * 	   downSpeed : 雪花颗粒下降速度 默认3000
 * 	  	      mX : 雪花颗粒偏移X 默认0.01
 * 	  	      mY ：雪花颗粒偏移Y 默认0.01
 * }
 * @see 使用方法：http://chendaiming.iteye.com/blog/2263399
 */
var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;
var container;
var particle;
var camera;
var scene;
var renderer;
// var mouseX = 0;
// var mouseY = 0;
// var mX = 0.01;
// var mY = 0.01;
// var windowHalfX = window.innerWidth / 2;
// var windowHalfY = window.innerHeight / 2;
var particles = [];
var particleImage = new Image();
function initsnow(images, downSpeed, X, Y, maxParticle, fuzzy) {
    particleImage.src = images;
    container = document.createElement("div");
//    container.className="invert";
    container.style.top = "-10px";
    container.style.height ="auto";
    container.style.width="auto";
    container.style.position ="auto";
    container.style.zIndex = "999999999";
    container.style.pointerEvents = "none";
    document.body.appendChild(container);
    if (fuzzy == undefined || fuzzy == "") {
        fuzzy = 70
    }
    var minParticle = 1;
    if (maxParticle == undefined || maxParticle == "") {
        maxParticle = 10000
    }
    if (downSpeed == undefined || downSpeed == "") {
        downSpeed = 3000
    }
    if (X != undefined && X != "") {
        mX = X
    }
    if (Y != undefined && Y != "") {
        mY = Y
    }
    camera = new THREE.PerspectiveCamera(fuzzy,SCREEN_WIDTH / SCREEN_HEIGHT,minParticle,maxParticle);
    camera.position.z = 1000;
    scene = new THREE.Scene();
    scene.add(camera);
    renderer = new THREE.CanvasRenderer();
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    var material = new THREE.ParticleBasicMaterial({
        map: new THREE.Texture(particleImage)
    });
    for (var i = 0; i < 500; i++) {
        particle = new Particle3D(material);
        particle.position.x = Math.random() * 2000 - 1000;
        particle.position.y = Math.random() * 2000 - 1000;
        particle.position.z = Math.random() * 2000 - 1000;
        particle.scale.x = particle.scale.y = 1;
        scene.add(particle);
        particles.push(particle)
    }
    container.appendChild(renderer.domElement);
    //document.addEventListener("mousemove", onDocumentMouseMove, false);
    document.addEventListener("touchstart", onDocumentTouchStart, false);
    document.addEventListener("touchmove", onDocumentTouchMove, false);
    document.addEventListener("touchend",onDocumentTouchEnd,false);
    // setInterval(loop, downSpeed / 60);
    setInterval(loop, downSpeed / 30);
}
// function onDocumentMouseMove(event) {
//     mouseX = event.clientX - windowHalfX;
//     mouseY = event.clientY - windowHalfY
// }
var touchStartX;
var touchFlag=0;
var touchSensitive=80;
function onDocumentTouchStart(event) {
    if (event.touches.length == 1) {
        event.preventDefault();
        touchStartX=0;
        touchStartX=event.touches[0].pageX;
        // mouseX = event.touches[0].pageX - windowHalfX;
        // mouseY = event.touches[0].pageY - windowHalfY
    }
}
function onDocumentTouchMove(event) {
    if (event.touches.length == 1) {
        event.preventDefault();
        var direction=event.touches[0].pageX-touchStartX;
        if (Math.abs(direction) > touchSensitive) {
                if (direction>0) {touchFlag = 1;}
                else if (direction<0) {touchFlag = -1;};
                //changeAndBack(touchFlag);
         }
        // mouseX = event.touches[0].pageX - windowHalfX;
        // mouseY = event.touches[0].pageY - windowHalfY
    }
}
    function onDocumentTouchEnd (event) {
        // if ( event.touches.length == 0 ) {
        //  event.preventDefault();
        //  touchEndX = event.touches[ 0 ].pageX ;
        //  touchEndY = event.touches[ 0 ].pageY ;
    
        // }这里存在问题
        var direction = event.changedTouches[ 0 ].pageX - touchStartX;

        changeAndBack(touchFlag);
    }


    function changeAndBack (touchFlag) {
        var speedX = 25*touchFlag;
        touchFlag = 0;
        for (var i = 0; i < particles.length; i++) {
            particles[i].velocity=new THREE.Vector3(speedX,-10,0);
        }
        var timeOut = setTimeout(";", 800);
        clearTimeout(timeOut);

        var clearI = setInterval(function () {
            if (touchFlag) {
                clearInterval(clearI);
                return;
            };
            speedX*=0.8;

            if (Math.abs(speedX)<=1.5) {
                speedX=0;
                clearInterval(clearI);
            };
            
            for (var i = 0; i < particles.length; i++) {
                particles[i].velocity=new THREE.Vector3(speedX,-10,0);
            }
        },100);


    }
function loop() {
    for (var i = 0; i < particles.length; i++) {
        var particle = particles[i];
        particle.updatePhysics();
        with (particle.position) {
            if (y < -1000) {
                y += 2000
            }
            if (x > 1000) {
                x -= 2000
            } else {
                if (x < -1000) {
                    x += 2000
                }
            }
            if (z > 1000) {
                z -= 2000
            } else {
                if (z < -1000) {
                    z += 2000
                }
            }
        }
    }
    // camera.position.x += (mouseX - camera.position.x) * mX;
    // camera.position.y += (-mouseY - camera.position.y) * mY;
    camera.lookAt(scene.position);
    renderer.render(scene, camera)
}
Particle3D = function(material) {
    THREE.Particle.call(this, material);
    // this.velocity = new THREE.Vector3(0,-8,0);
    // this.velocity.rotateX(randomRange(-45, 45));
    // this.velocity.rotateY(randomRange(0, 360));
    // this.gravity = new THREE.Vector3(0,0,0);
    this.velocity=new THREE.Vector3(0,0,0);
    this.velocity.rotateY(7);
    this.gravity=new THREE.Vector3(0,0,1.5);
    this.drag = 1
}
;
Particle3D.prototype = new THREE.Particle();
Particle3D.prototype.constructor = Particle3D;
Particle3D.prototype.updatePhysics = function() {
    this.velocity.multiplyScalar(this.drag);
    this.velocity.addSelf(this.gravity);
    this.position.addSelf(this.velocity);
}
;
var TO_RADIANS = Math.PI / 180;
THREE.Vector3.prototype.rotateY = function(angle) {
    cosRY = Math.cos(angle * TO_RADIANS);
    sinRY = Math.sin(angle * TO_RADIANS);
    var tempz = this.z;
    var tempx = this.x;
    this.x = (tempx * cosRY) + (tempz * sinRY);
    this.z = (tempx * -sinRY) + (tempz * cosRY)
}
;
THREE.Vector3.prototype.rotateX = function(angle) {
    cosRY = Math.cos(angle * TO_RADIANS);
    sinRY = Math.sin(angle * TO_RADIANS);
    var tempz = this.z;
    var tempy = this.y;
    this.y = (tempy * cosRY) + (tempz * sinRY);
    this.z = (tempy * -sinRY) + (tempz * cosRY)
}
;
THREE.Vector3.prototype.rotateZ = function(angle) {
    cosRY = Math.cos(angle * TO_RADIANS);
    sinRY = Math.sin(angle * TO_RADIANS);
    var tempx = this.x;
    var tempy = this.y;
    this.y = (tempy * cosRY) + (tempx * sinRY);
    this.x = (tempy * -sinRY) + (tempx * cosRY)
}
;
function randomRange(min, max) {
    return ( (Math.random() * (max - min)) + min)
}
;
